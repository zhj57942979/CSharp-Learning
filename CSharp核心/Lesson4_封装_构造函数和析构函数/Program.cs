using System;

namespace Lesson4_封装_构造函数和析构函数
{

    #region 知识点一 构造函数
    //基本概念
    //在实例化对象时 调用用于初始化的函数
    //如果不写 默认存在一个无参构造函数

    //构造函数的写法
    //1 没有返回值
    //2 函数名和类名必须相同
    //3 没有特殊需求时 一般都是public的
    class Person
    {
        public string name;
        public int age;

        //类中 是允许自己申明无参构造函数的
        //结构体是不允许的
        public Person()
        {
            name = "唐老师";
            age = 18;
        }

        public Person(int age)
        {
            //this代表当前调用该函数的对象自己
            this.age = age;
        }

        public Person(string name)
        {
            this.name = name;
        }

        public Person(int age, string name):this(name)
        {
            // :this()先进无参构造函数
            //  this(name)会调用一个参数name的函数
            //  无参构造可以this(常量)调用一个参数的函数
            //  this的作用 复用代码
            Console.WriteLine("Person两个参数构造函数调用");
        }
        //当引用类型的堆内存被回收时
        //当垃圾被回收时会触发调用
        ~Person()
        {

        }
    }

    //4 构造函数可以被重载
    //5 this代表当前调用该函数的对象自己

    //注意
    // 如果不自己是实现无参构造函数而实现有参构造函数
    // 会失去默认的无参构造
    #endregion

    #region 知识点二 构造函数特殊写法
    //可以通过this 重用构造函数代码
    //访问修饰符 构造函数名（参数列表）：this(参数1,参数2.....)
    #endregion

    #region 知识点三 析构函数
    //基本概念
    //当引用类型的堆内存被回收时 会调用该函数
    //对于需要手动管理内存的语言比如C++ 需要在析构函数中做一些内存回收处理
    //但是C#中存在自动垃圾回收机制GC
    //所以我们几乎不会怎么使用析构函数 除非你想在某一个对象被垃圾回收时 做一些特殊处理
    //注意
    //在unity开发中析构函数几乎不会被使用 所以这个知识点只做了解

    //基本语法
    // `类名{
    // }
    #endregion

    #region 知识点四 垃圾回收机制
    //垃圾回收 英文 Garbage Collector
    //垃圾回收的过程时在遍历 堆heap 上动态分配的所有对象
    //通过识别他们是否被引用来确定哪些对象时垃圾 哪些垃圾仍然被使用
    //所谓垃圾就是没有被任何变量 对象引用的内容

    //垃圾回收有很多算法 比如
    //引用计数reference counting
    //标记清除mark sweep
    //标记整理mark compact
    //复制集合copy collection

    //注意
    //GC只负责堆heap内存的垃圾回收
    //引用类型都是存在堆heap中的 所以他的分配和释放都通过垃圾回收机制来管理

    //栈stack上的内存是由系统自动管理的
    //值类型在栈stack中分配内存的 他们有自己的生命周期 不用对他们进行管理 会自动分配和释放

    //C#内存回收机制的大概原理
    //0代内存    1代内存    2代内存
    //代的概念
    //代是垃圾回收机制使用的一种算法（分代算法）
    //新分配的对象都会被配置在第0代内存中
    //每次分配都可能会进行垃圾回收以释放内存（0代内存满时）

    //在一次内存回收开始时 垃圾回收器会认为堆中全是垃圾 会进行一下两步
    //1 标记对象 从根（静态字段 方法参数）开始检查引用对象 标记后为可达对象 未标记为不可达对象
    // 不可达对象就认为时垃圾
    // 搬迁对象压缩堆 （挂起执行托管代码线程） 释放未标记的对象 搬迁可达对象 修改引用地址
    // 搬迁 把可达对象从0代移动到1代 会在1代中按顺序整理好 1代再次满的时候会再次触发内存释放-0代1代一起释放 移入2代

    //大对象总被认为是第二代内存 目的是减少性能损耗 提高性能
    //不会对大对象进行搬迁压缩 85000字节(83kb)以上的对象为大对象
    #endregion

    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("构造函数和析构函数");

            Person p = new Person(18,"唐老师");
            Console.WriteLine(p.age);

            p = null;
            //游戏中自动触发GC会导致卡顿
            //一般在loading状态中手动触发GC 不会频繁调用
            GC.Collect();
        }
    }
}
